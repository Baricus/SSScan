mod libssh;

use scoped_thread_pool::Pool;

use libssh::{SSHSession, PubKey, ssh_keytypes as keytypes, ssh_auth as auth};

use clap::Parser;

use core::panic;
use std::{path::PathBuf, io::stdin};

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Args {
    /// The public key to test against IPs
    #[command(flatten)]
    key: Key,

    /// # of threads to spawn to check IPs against the key
    /// 
    /// NOTE: This can be much higher than the number of cores,
    ///       as this is an IO bound task rather than CPU bound
    #[arg(short, long, value_name="NUM_THREADS", default_value="1")]
    threads: usize,

    /// Port to connect to via ssh
    #[arg(short, long, value_name="PORT", default_value="22")]
    port: String,

    /// username to connect with
    #[arg(value_name="REMOTE_USER", required=true)]
    username: String,

    /// Whether to allow AUTH_PARTIAL responses.  
    /// LibSSH accepts this as a possibility, but the 
    /// SSH auth RFC does not allow them.
    ///
    /// This usually occurs erroneously from testing,
    /// so this is set to false by default.
    #[arg(long="partial", default_value="false")]
    allow_partial: bool,
}

#[derive(Parser, Debug, Clone)]
#[clap(group(clap::ArgGroup::new("key").required(true).multiple(false).args(&["b64", "file"])))]
struct Key {
    /// A base64 encoded public key
    #[arg(short, long, value_name="KEY_B64", requires="keytype")]
    b64: Option<String>,

    /// the type of key in the b64 parameter
    #[arg(long="type")]
    keytype : Option<keytypes>,

    /// A public key file to read a key from
    #[arg(short, long, value_name="KEY_FILE", conflicts_with="keytype")]
    file: Option<PathBuf>,
}

fn get_key(k: Key) -> Result<PubKey, libssh::Error> {
    match k.b64 {
        Some(b64) => PubKey::from_base64(&b64, k.keytype.unwrap()),
        None => {
            match k.file {
            Some(f) => PubKey::from_file(&f),
            None => panic!("No key passed on command line!"),
            }
        }
    }
}

fn test_host(partial: bool, host: String, port: &str, user: &str, key: &PubKey) {
    let session = SSHSession::new();
    session.options_set_host(&host);
    session.options_set_user(user);
    session.options_set_port_str(port);

    // if we connected, try the key
    match session.connect() {
        Ok(session) => {
            let b = session
                .get_server_banner()
                .unwrap_or(""); // if we can't get the banner, don't print it

            // actually send the key packet
            let r = session.userauth_try_publickey(&key);
            match r {
                // this key is allowed or partially allowed
                Ok(auth::SSH_AUTH_SUCCESS) => println!("{}\t{}", &host, &b),
                // partial seems to come as an error response from non-compliant ssh servers
                // so we only include it in the output if requested
                Ok(auth::SSH_AUTH_PARTIAL) => {
                    if partial {
                        println!("{}\t{}\t\t**PARTIAL**", &host, &b)
                    }
                    else {
                        ()
                    }
                },
                // we didn't get access so print nothing
                Ok(auth::SSH_AUTH_DENIED) => (),

                // something went wrong
                Err(auth::SSH_AUTH_AGAIN) => eprintln!("Error: nonblocking predicate returned in userauth_try_publickey"),
                Err(auth::SSH_AUTH_INFO)  => eprintln!("Error: Impossible return (AUTH_INFO) for userauth_try_publickey"),
                Err(auth::SSH_AUTH_ERROR) => eprintln!("Error: LibSSH error: {}", session.get_error()),

                // impossible combinations
                // I really should rework this API
                // but it's autogenerated and I don't know how D:
                _ => panic!("Impossible!"),
            }

            // drop the connection abruptly to save packets rather than gracefully
            session.silent_disconnect();
        }
        // we couldn't connect at all
        Err(_) => (), 
    };
}

fn main() {
    let args = Args::parse();

    let key  = get_key(args.key).expect("Invalid key");
    let user = args.username;
    let port = args.port;

    let pool = Pool::new(args.threads);
    let stdin = stdin();

    let partial = args.allow_partial;

    // wrap this all in a scope so this doesn't break
    // this is an annoying pain point
    // since we can't share the values, even
    // if we wait for the threads to finish at the end
    //
    // I'd love not to need this specific kind of thread pool, but at least it works
    pool.scoped(|s| {
        let mut l = true;
        while l {

            // get a line off stdin
            let line = {
                let mut buff = String::new();
                let r = stdin.read_line(&mut buff);
                match r {
                    Ok(..)  => buff.trim().to_string(),
                    Err(..) => " ".to_owned(),
                }
            };

            // if we receive an empty input line, stop the loop
            if line.is_empty() {
                l = false;
            }
            else {
                s.execute(|| test_host(partial, line, &port, &user, &key));
            }
        }
        
        // wait for all jobs to end before we exit
        // (even though this should happen already)
        s.join();
    });
}
